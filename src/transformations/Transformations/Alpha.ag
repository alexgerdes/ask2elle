-----------------------------------------------------------------------------
-- Copyright 2014, Open Universiteit Nederland. This file is distributed
-- under the terms of the GNU General Public License. For more information,
-- see the file "LICENSE.txt", which is included in the distribution.
-----------------------------------------------------------------------------
-- |
-- Maintainer  :  alex@botkes.nl
-- Stability   :  provisional
-- Portability :  unknown
--
-- TODO: - alternative: make subst attr chained for Pat/Pats and update map
--                      / fresh there
--       - decls in a where clause also range over patterns in the patbind/
--         funbind
--       - move scope and free vars to different file (Scope.ag)
-----------------------------------------------------------------------------

-- run uuagc (using the uuagcpp.sh shell script) as a pre-processor for GHC;
-- put the script, which resides in the tools directory, in your PATH 
-- {-# OPTIONS_GHC -F -pgmF uuagcpp.sh -optF -scf #-}

optpragmas
{
{-# LANGUAGE FlexibleContexts #-}
{-# OPTIONS -fno-warn-unused-top-binds -fno-warn-unused-matches #-}
}

module {Language.Haskell.Transformations.Alpha} 
       {alphaRename, AlphaInfo(..), alphaInfo, runTests}  -- exports
{
import Data.Generics.Uniplate.Direct 
import Data.List
import Data.Maybe
import qualified Data.Map as M
import Language.Haskell.Syntax
import Language.Haskell.Utils (noShadow)
import Test.QuickCheck
}

{
data AlphaInfo = AlphaInfo
    { free     :: Names   -- ^ Free variables in a Module
    , invSubst :: Subst   -- ^ Mapping from alpha name to original name
    , result   :: Module  -- ^ Alpha renamed Module
    } deriving (Show)

type Subst = M.Map Name Name

updateSubst :: Names -> Names -> Subst -> Subst
updateSubst ks vs subst = M.fromList (zip ks vs) `M.union` subst

substitute :: Name -> Subst -> Name
substitute k = fromMaybe k . M.lookup k

inverseSubst :: Subst -> Subst
inverseSubst = M.foldrWithKey (flip M.insert) M.empty

alphaInfo :: Names -> Module -> AlphaInfo
alphaInfo fixed = unc4 AlphaInfo . flip sem_Module fixed
  where 
    unc4 f (a, b, c) = f b c a

alphaRename :: Names -> Module -> Module
alphaRename fixed = result . alphaInfo fixed

freeVars :: Module -> Names
freeVars = free . alphaInfo []

fresh :: Names
fresh = [Ident ('x' : show i) | i <- [(1 :: Int)..]]
}

include "../Syntax.ag"

attr Module
  inh fixed                            :: Names
  syn free     use {union}   {[]}      :: Names
  syn invSubst use {M.union} {M.empty} :: Subst
  syn copy                             :: self

attr Body Decl Decls FunBind FunBinds 
  inh subst                            :: Subst
  inh fixed                            :: Names
  {-chn inscope  use {union}   {[]}      :: Names-}  -- in new uuagc syntax this is not allowed anymore, strange...
  chn inscope                          :: Names
  chn fresh                            :: Names
  syn free     use {union}   {[]}      :: Names
  syn invSubst use {M.union} {M.empty} :: Subst
  syn copy                             :: self

attr Pat Pats
  inh subst                            :: Subst 
  inh fixed                            :: Names
  syn inscope  use {union}   {[]}      :: Names
  syn invSubst use {M.union} {M.empty} :: Subst
  syn copy                             :: self

attr Expr Exprs RefactorChoice RefactorChoices Alt Alts GuardedExpr GuardedExprs MaybeExpr Rhs
  inh inscope                          :: Names 
  inh subst                            :: Subst
  inh fixed                            :: Names
  chn fresh                            :: Names
  syn free     use {union}   {[]}      :: Names
  syn invSubst use {M.union} {M.empty} :: Subst
  syn copy                             :: self

attr Literal Name MaybeName
  syn copy                             :: self

sem Module
  | Module    body.fresh     = fresh \\ @body.free  -- make sure we do not capture free vars
                  .subst     = M.empty
                  .inscope   = []

sem Body
  | Body      decls.inscope  = @inscope `union` @lhs.inscope  -- a bit odd construction, but a toplevel declaration is in scope of other declarations
                   .subst    = @subst
                   .fresh    = drop (length @inscope) @lhs.fresh
              lhs.free       = @decls.free \\ @decls.inscope
              loc.subst      = updateSubst @inscope @lhs.fresh @lhs.subst
                 .inscope    = @decls.inscope \\ @lhs.fixed

sem Decl
  | DFunBinds lhs.inscope    = take 1 @funbinds.inscope  -- assuming alpha renaming is done after type checking
  | DPatBind  lhs.inscope    = @pat.inscope
  | DHole     lhs.inscope    = []

sem Decls
  | Nil       lhs.inscope    = []
  | Cons      lhs.inscope    = @hd.inscope `union` @tl.inscope

sem Expr
  | Var       lhs.free       = [@name.copy] 
                 .copy       = Var $ substitute @name.copy @lhs.subst
                 .invSubst   = inverseSubst @lhs.subst
  | Lambda    expr.inscope   = @inscope `union` @lhs.inscope
                  .subst     = @subst 
                  .fresh     = drop (length @inscope) @lhs.fresh
              pats.subst     = @subst
              lhs.free       = @expr.free \\ @pats.inscope
              loc.subst      = updateSubst @inscope @lhs.fresh @lhs.subst 
                 .inscope    = @pats.inscope \\ @lhs.fixed
  | Let       expr.inscope   = @inscope `union` @lhs.inscope
                  .subst     = @subst
                  .fresh     = @decls.fresh  -- copy rule?
              decls.subst    = @subst
                   .inscope  = @inscope `union` @lhs.inscope
                   .fresh    = drop (length @inscope) @lhs.fresh
              lhs.free       = @expr.free \\ @decls.inscope
              loc.subst      = updateSubst @inscope @lhs.fresh @lhs.subst
                 .inscope    = @decls.inscope \\ @lhs.fixed

sem Alt
  | Alt       rhs.inscope    = @inscope `union` @lhs.inscope
                 .subst      = @subst
                 .fresh      = drop (length @inscope) @lhs.fresh
              pat.subst      = @subst
              lhs.free       = @rhs.free \\ @pat.inscope
              loc.subst      = updateSubst @inscope @lhs.fresh @lhs.subst 
                 .inscope    = @pat.inscope \\ @lhs.fixed
sem FunBinds
  | Nil       lhs.inscope    = []
  | Cons      lhs.inscope    = @hd.inscope `union` @tl.inscope

sem FunBind
  | FunBind   rhs.inscope    = @inscope `union` @lhs.inscope  -- name is already in subst
                 .subst      = @subst
                 .fresh      = drop (length @inscope) @lhs.fresh
              pats.subst     = @subst
              lhs.inscope    = [@name.copy]
                 .free       = @rhs.free \\ @pats.inscope
                 .copy       = FunBind @feedback (substitute @name.copy @lhs.subst) @pats.copy @rhs.copy
                 .invSubst   = inverseSubst @lhs.subst `M.union` @pats.invSubst
              loc.subst      = updateSubst @inscope @lhs.fresh @lhs.subst  -- funbind name is already in subst, done in body 
                 .inscope    = @pats.inscope \\ @lhs.fixed
  | FBHole    lhs.inscope    = []

sem Pat
  | PVar      lhs.inscope    = [@name.copy] 
                 .copy       = PVar $ substitute @name.copy @lhs.subst
                 .invSubst   = inverseSubst @lhs.subst
  | PAs       lhs.inscope    = @name.copy : @pat.inscope
                 .copy       = PAs (substitute @name.copy @lhs.subst) @pat.copy
                 .invSubst   = inverseSubst @lhs.subst
  | PWildcard lhs.inscope    = [Special ""]  -- a wildcard takes one fresh var out of the pool

sem Rhs  -- do right to left chaining
  | Rhs       expr.inscope   = @lhs.inscope `union` @inscope
                  .subst     = @subst
                  .fresh     = @where.fresh
              where.fresh    = drop (length @inscope) @lhs.fresh
                   .subst    = @subst
                   .inscope  = @inscope `union` @lhs.inscope
              lhs.free       = @expr.free \\ @where.inscope
                 .fresh      = @expr.fresh
              loc.subst      = updateSubst @inscope @lhs.fresh @lhs.subst 
                 .inscope    = @where.inscope \\ @lhs.fixed

  | GRhs      gexprs.inscope = @lhs.inscope `union` @inscope
                    .subst   = @subst 
                    .fresh   = @where.fresh
              where.fresh    = drop (length @inscope) @lhs.fresh
                   .subst    = @subst
                   .inscope  = @inscope `union` @lhs.inscope
              lhs.free       = @gexprs.free \\ @where.inscope
                 .fresh      = @gexprs.fresh
              loc.subst      = updateSubst @inscope @lhs.fresh @lhs.subst
                 .inscope    = @where.inscope \\ @lhs.fixed

{
-- Test functions/values ------------------------------------------------------
f1, g, h, x1, y :: Name
f1 = Ident "f"; g = Ident "g"; h = Ident "h"; x1 = Ident "x"; y = Ident "y"

e :: Expr
e = Lambda [PVar x1] (Lambda [PVar x1] (Var x1))


d1, d2, d3 :: Decl
d1 = DPatBind (PVar f1) (Rhs e [d2])
d2 = DPatBind (PVar g) (Rhs e [])
d3 = DFunBinds [FunBind Nothing h [PVar x1, PVar y] (Rhs (Var (Ident "z") `App` [Var x1]) [])]

m1, m2, m3 :: Module
m1 = Module NoName $ Body [d1, d2, d3]

m2 = Module NoName (Body [DFunBinds [FunBind Nothing (Ident "f") [] (Rhs (Hole "1") [DHole "1"])]])

m3 = Module NoName (Body [DFunBinds [FunBind Nothing (Ident "allpairs") [PVar (Ident "xs")] (Rhs (App (Var (Ident "concatMap")) [Hole "6",Var (Ident "xs")]) [DFunBinds []])]])

-- Properties -----------------------------------------------------------------
propIdempotency :: Module -> Property 
propIdempotency m = let f = alphaRename [] in property $ f m == f (f m)

propUniqueBindVars :: Module -> Property
propUniqueBindVars m = let bs = bindings $ alphaRename [] m
                       in  property $ bs == nub bs

bindings :: Module -> Names
bindings m = [n | PVar n          <- universeBi m]
          ++ [n | PAs n _         <- universeBi m]
          ++ [f | FunBind _ f _ _ <- universeBi m]

propNoShadowing :: Module -> Property
propNoShadowing = property . noShadow . alphaRename []

propNoCapturing :: Module -> Property
propNoCapturing m = property $ freeVars m == freeVars (alphaRename [] m)

propFixedNames :: Module -> Property
propFixedNames m = forAll (genSlice $ names m) $ \fixed -> 
    null $ fixed \\ names (alphaRename fixed m)
  where
    names x = nub [n | n@(Ident _) <- universeBi x]

genSlice :: [a] -> Gen [a]
genSlice xs = do 
  i <- choose (0, length xs - 1)
  j <- choose (0, length xs - i)
  return $ take j $ drop i xs

propInverseSubst :: Module -> Property
propInverseSubst m = property $ transformBi (flip substitute subst) m' == m
  where
    AlphaInfo {invSubst = subst, result = m'} = alphaInfo [] m

runTests :: IO ()
runTests = quickCheck $ conjoin $ map ($ m1) [ propIdempotency, propNoShadowing
                                             , propNoCapturing, propFixedNames
                                             , propInverseSubst, propUniqueBindVars ]
}
