
{-# OPTIONS_GHC -Wno-orphans #-}
module GhcLib.Transform.Inline where


import GHC.Plugins qualified as GHC
import qualified GHC.Types.Name as GHCOcc


import Control.Monad.State
import Data.Generics.Uniplate.Data
import Data.List ( (\\) )

import GhcLib.GHCRelated.Bag ()
import GhcLib.Transform.Utility
import Data.Bifunctor (Bifunctor(second))
import qualified GHC.Core.Map.Type as GHC
import GhcLib.GHCRelated.BinderEquality


{-|
  inline takes a global binder and a list of binders that use it, returns the inlined versions of binders
  It takes one argument, of type 'Int'.
-}
-- * Major difference from Matilda's code, if it doesn't work, go check this out 
inline :: GHC.CoreBind -> [GHC.CoreBind] ->  [GHC.CoreBind]
inline globalBind globalBindUsers = insertBind globalBind globalBindUsers



inlineBinds :: String -> GHC.CoreProgram -> GHC.CoreProgram
-- | Inline recursive binders as let-recs, and non recursive binders directly
inlineBinds exfun = inlineBind []
    where inlineBind :: GHC.CoreProgram -> GHC.CoreProgram -> GHC.CoreProgram
          -- Better to rewrite this in tail recursion
          inlineBind acc [] = acc
          inlineBind acc (bind:binds)
              |   not (isSpecVar v) -- remove bindings generated by compiler, like $trModule
                , exfun /= GHC.getOccString v  -- dont inline the student's solution function
                , length (fst usedBy) == 1 -- * right now if the top level binding is only used once, inline it
                , notTyCon . head . fst $ usedBy = -- ? confused with this example
                            let newBinds  = inline bind $ fst usedBy -- inline the current bind in all appearances
                                notInvolved = snd usedBy             -- top binders dont invoke the current bind
                                -- remaining = fmap GHC.deBruijnize otherBindings \\ fmap GHC.deBruijnize usedBy

                            in inlineBind [] $ newBinds ++ notInvolved 
              | otherwise = inlineBind (bind:acc) binds
                where v :: GHC.Var
                      v = getBindTopVar bind
                      otherBindings :: [GHC.CoreBind]
                      otherBindings = acc ++ binds

                      usedBy :: ([GHC.CoreBind],[GHC.CoreBind])
                      -- | Get all binders referencing the current binding
                      usedBy = getBindersByVar otherBindings bind
                      -- | Check if the variable is used in a type constructor application
                      -- |  True -> It's not used in a type constructor application
                      -- |  False -> It's used in a type constructor application
                      notTyCon x = not (isTyConApp . GHC.varType . getBindTopVar $ x)



insertBind :: GHC.CoreBind -> [GHC.CoreBind] -> [GHC.CoreBind]
-- | Inline global binder in all other binders using it 
--  recursive binders are inlined as a let-rec
insertBind n@(GHC.NonRec v e) bs = map insertB bs -- inline another nonrec 
    where
          insertB :: GHC.CoreBind -> GHC.CoreBind
          -- | Replace every occurance of the variable with the expression in the binders
          insertB  = transformBi $ \case
            (GHC.Var v') | v == v' -> e
            rest -> rest

insertBind (GHC.Rec ls@((v,e):es)) bs = map insertR bs
    where insertR :: GHC.CoreBind -> GHC.CoreBind
          insertR bind@(GHC.NonRec b (GHC.Lam x ex)) = GHC.NonRec b $ GHC.Lam x $
                                        GHC.Let (GHC.Rec ((uv,e'):es)) (subsVar uv v ex)
          insertR bind@(GHC.NonRec b ex) = GHC.NonRec b $
                                         GHC.Let (GHC.Rec ((uv,e'):es)) (subsVar uv v ex)
          insertR bind@(GHC.Rec es') = GHC.Rec $ map (second (subsVar uv v)) (es'++ ls)
          uv :: GHC.Var
          -- | make the global binder local
          uv = GHC.localiseId v
          -- | replace every occurance of the global binder with the local ones
          e' :: GHC.CoreExpr
          e' = subsVar uv v e
insertBind (GHC.Rec []) bs = bs

recToLetRec ::  GHC.UniqSupply -> GHC.CoreProgram -> GHC.CoreProgram
-- | Inline recursive binders as let-recs when appropriate
recToLetRec letRecSupply p = evalState (recToLR p) $ HoleCandidates 0 $ GHC.listSplitUniqSupply letRecSupply
    where recToLR :: GHC.CoreProgram -> State HoleCandidates GHC.CoreProgram
          recToLR [] = pure []
          recToLR (b:bs) = case b of
                          GHC.Rec [] -> pure []
                          (GHC.Rec ((v,e):ls)) -> do
                                          holeIdCandidates <- gets holeNameCandicate
                                          holeCount <- gets holeCount
                                          let holeCandidate = head holeIdCandidates
                                          modify $
                                              \s -> s { holeCount = holeCount + 1, holeNameCandicate = tail holeIdCandidates }
                                          let topLevelBinder = fresh holeCandidate v
                                              e' = subsVar topLevelBinder v e
                                              -- ! This is declared, but not used 
                                              -- ls' = map (subsVar topLevelBinder v . snd) ls
                                              b' = GHC.NonRec v (GHC.Let (GHC.Rec ((topLevelBinder,e'):ls)) (GHC.Var topLevelBinder))
                                          -- bs' <- recToLR bs
                                          -- TODO : Check why bs instead bs' is used here, is it a huristic solution for only 1 recursive problem?
                                          recToLR bs >>= \bs' -> return $ b':bs
                          nr@(GHC.NonRec _ _) -> recToLR bs >>= \bs' -> return $ nr:bs'
          fresh :: GHC.UniqSupply -> GHC.Var -> GHC.Var
          fresh us var =
              let uq = GHC.uniqFromSupply us
                  name = makeName (GHC.getOccString var) uq $ GHCOcc.getSrcSpan (GHC.varName var) -- reuse id information from top-level
              in GHC.setIdNotExported (makeLocal $ GHC.setVarName var name)


