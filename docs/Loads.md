it first calls `depanalE` with empty excluded modules, represented by `[]` and only single root allowed, represented by `False`.

# depanalE

```haskell
hsc_env <- getSession
```  
The session was setted up when we were calling `runGhcT` function, check `newHscEnv` for specific values.

So far, we have already performed `setFlags` which modifies the dynamic flag field, `hs_dflags`, and `setTarget` which modifies `hsc_targets` field.

## (errs, mod_graph) <- depanalPartial excluded_mods allow_dup_roots
The command is in effect `depanalPartial [] false`










# depanalPartial 
```haskell
hsc_env <- getSession
```
At this step, `hsc_env` should hold the same value as the one at line 6 in `depanalE`,
```haskell
let
   dflags = hsc_dflags hsc_env
   targets = hsc_targeets hsc_env
   old_graph = hsc_mod_grapph hsc_env
   logger = hsc_logger hsc_env
```
`dflags` holds all dynamic flags we setted.
`targets` is a singleton list which holds the student's program 
old_graph is `emptyMG`, the empty module graph.
logger holds the value generated by `initLogger`

```haskell
withTiming logger dflags (text "Chasing Dependencies") (const ()) $ do
	liftIO $ debugTraceMsg logger dfags 2 (hcat [
		text "Chasing modules from: ",
		hcat (punctutate comma (map pprTarget targets))
	])
```

The functionality of `withTiming` is irrelevant here, the main gist is that it performs the do operation and times it. And the do operation here, from my understanding, is just pretty printing target haskell files. 

```haskell
liftIO $ flushFinderCaches hsc_env
```


```haskell
flushFinderCaches :: HscEnv -> IO ()
flushFinderCaches hsc_env = 
	atomicModifyIORef' fc_ref $ \fm -> (filterInstalledModuleEnv is_ext fm, ())
	where 
		fc_ref = hsc_FC hsc_env
		home_unit = hsc_home_unit hsc_env
		is_ext mod _ = not (isHomeInstalledModule home_unit mod)
```
`fc_ref` holds `newIORef emptyInstalledModuleEnv` 
`emptyInstalledModuleEnv` is Empty map whose keys are module uniques and values are `installedFindResult`

`home_unit` holds `panic : hsc_unit_env not initialized`, later `isHomeInstalledModule` tries to check `mod` whether inside `home_unit` or not by comparing `home_unit`'s number with mod's. Why it doesn't lead to panic, because of laziness!. `filterInstalledModuleEnv` just returns empty map if th e map is empty.

So, in this case, `flushFinderCaches` does literally nothing.